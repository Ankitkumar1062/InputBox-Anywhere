/**
 * CSS Modifier
 * Dynamically modifies CSS based on rules provided or generated by LLM
 */

const CssModifier = (function() {
  // Keep track of all injected style elements
  const injectedStyles = [];
  
  /**
   * Apply a set of CSS rules to the page
   * @param {Array} rules - An array of CSS rule objects
   */
  function applyRules(rules) {
    console.log("CssModifier: Applying rules", rules);
    if (!rules || !Array.isArray(rules) || rules.length === 0) {
      console.warn("CssModifier: No valid rules to apply");
      return;
    }
    
    // Remove previously injected styles
    removeAllRules();
    
    // Process and apply each rule
    rules.forEach((rule, index) => {
      if (!rule.selector || !rule.styles) {
        console.warn("CssModifier: Invalid rule", rule);
        return;
      }
      
      // Create a style element for this rule
      const styleElement = document.createElement('style');
      styleElement.id = `custom-input-box-css-rule-${index}`;
      styleElement.setAttribute('data-custom-input-box', 'true');
      
      // Build the CSS rule
      let cssText = `${rule.selector} {\n`;
      
      // Add each style property
      if (typeof rule.styles === 'object') {
        Object.entries(rule.styles).forEach(([property, value]) => {
          // Sanitize the property and value
          property = property.replace(/[^a-zA-Z0-9-]/g, '');
          value = String(value).replace(/[<>]/g, ''); // Basic XSS protection
          cssText += `  ${property}: ${value} !important;\n`;
        });
      }
      
      cssText += `}\n`;
      
      // Add the rule to the style element
      styleElement.textContent = cssText;
      
      try {
        // Add to the document
        document.head.appendChild(styleElement);
        
        // Keep track for later removal
        injectedStyles.push(styleElement);
        console.log("CssModifier: Added style for", rule.selector);
      } catch (error) {
        console.error("CssModifier: Error applying rule", error);
      }
    });
    
    console.log("CssModifier: Applied", injectedStyles.length, "style elements");
    
    // Add visual feedback that CSS has been modified
    showCssIndicator(rules.length);
  }
  
  /**
   * Remove all injected CSS rules
   */
  function removeAllRules() {
    console.log("CssModifier: Removing all rules");
    
    // Remove each injected style element
    injectedStyles.forEach(styleElement => {
      if (styleElement && styleElement.parentNode) {
        styleElement.parentNode.removeChild(styleElement);
      }
    });
    
    // Clear the array
    injectedStyles.length = 0;
    
    // Also look for any other style elements we might have missed
    const staleStyles = document.querySelectorAll('style[data-custom-input-box="true"]');
    staleStyles.forEach(element => {
      if (element.parentNode) {
        element.parentNode.removeChild(element);
      }
    });
    
    // Remove any indicators
    const indicator = document.getElementById('css-modifier-indicator');
    if (indicator && indicator.parentNode) {
      indicator.parentNode.removeChild(indicator);
    }
    
    console.log("CssModifier: All rules removed");
  }
  
  /**
   * Show a visual indicator that CSS has been modified
   * @param {Number} ruleCount - Number of rules applied
   */
  function showCssIndicator(ruleCount) {
    // Remove any existing indicator
    const existingIndicator = document.getElementById('css-modifier-indicator');
    if (existingIndicator && existingIndicator.parentNode) {
      existingIndicator.parentNode.removeChild(existingIndicator);
    }
    
    // Create indicator
    const indicator = document.createElement('div');
    indicator.id = 'css-modifier-indicator';
    indicator.style.position = 'fixed';
    indicator.style.bottom = '10px';
    indicator.style.right = '10px';
    indicator.style.background = 'rgba(74, 144, 226, 0.9)';
    indicator.style.color = 'white';
    indicator.style.padding = '8px 12px';
    indicator.style.borderRadius = '4px';
    indicator.style.fontSize = '12px';
    indicator.style.fontFamily = 'Arial, sans-serif';
    indicator.style.zIndex = '9999';
    indicator.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
    indicator.style.transition = 'opacity 0.5s ease';
    indicator.textContent = `Custom Input Box: ${ruleCount} CSS rules applied`;
    
    // Add an icon
    const icon = document.createElement('span');
    icon.textContent = 'âœ“ ';
    icon.style.fontWeight = 'bold';
    indicator.insertBefore(icon, indicator.firstChild);
    
    document.body.appendChild(indicator);
    
    // Hide after 4 seconds
    setTimeout(() => {
      indicator.style.opacity = '0';
      setTimeout(() => {
        if (indicator && indicator.parentNode) {
          indicator.parentNode.removeChild(indicator);
        }
      }, 500);
    }, 4000);
  }
  
  /**
   * Find the appropriate selectors for input fields
   * @returns {Array} - An array of CSS rules for input fields
   */
  function findInputSelectors() {
    console.log("CssModifier: Finding input selectors");
    const rules = [];
    
    // Look for input fields and textareas
    const inputs = document.querySelectorAll('input[type="text"], input[type="email"], input[type="search"], input[type="url"], input[type="tel"], textarea, [contenteditable="true"]');
    
    inputs.forEach((input, index) => {
      // Only process visible inputs
      if (!isElementVisible(input)) return;
      
      // Generate a specific selector for this input
      const selector = generateSpecificSelector(input);
      
      if (selector) {
        rules.push({
          selector,
          element: input,
          type: input.tagName.toLowerCase(),
          position: getElementPosition(input)
        });
      }
    });
    
    console.log("CssModifier: Found", rules.length, "input selectors");
    return rules;
  }
  
  /**
   * Generate a specific CSS selector for an element
   * @param {HTMLElement} element - The element to generate a selector for
   * @returns {String} - A CSS selector
   */
  function generateSpecificSelector(element) {
    if (!element) return null;
    
    // Start with the element's tag
    let selector = element.tagName.toLowerCase();
    
    // Add ID if available
    if (element.id) {
      selector += `#${element.id}`;
      return selector; // ID should be unique, so we can stop here
    }
    
    // Add classes
    if (element.classList.length > 0) {
      Array.from(element.classList).forEach(className => {
        selector += `.${className}`;
      });
    }
    
    // Add attributes for additional specificity
    if (element.name) {
      selector += `[name="${element.name}"]`;
    }
    
    // If the selector is still just the tag, add more specificity
    if (selector === element.tagName.toLowerCase()) {
      // Add parent information
      const parent = element.parentElement;
      if (parent && parent.tagName !== 'BODY') {
        let parentSelector = parent.tagName.toLowerCase();
        if (parent.id) {
          parentSelector += `#${parent.id}`;
        } else if (parent.classList.length > 0) {
          parentSelector += `.${Array.from(parent.classList)[0]}`;
        }
        selector = `${parentSelector} > ${selector}`;
      }
      
      // Add type for inputs
      if (element.tagName.toLowerCase() === 'input' && element.type) {
        selector += `[type="${element.type}"]`;
      }
    }
    
    return selector;
  }
  
  /**
   * Check if an element is visible
   * @param {HTMLElement} element - The element to check
   * @returns {Boolean} - True if the element is visible
   */
  function isElementVisible(element) {
    if (!element) return false;
    
    try {
      const style = window.getComputedStyle(element);
      return style.display !== 'none' && style.visibility !== 'hidden' && element.offsetParent !== null;
    } catch (error) {
      console.error("CssModifier: Error checking visibility", error);
      return false;
    }
  }
  
  /**
   * Get the position of an element relative to the viewport
   * @param {HTMLElement} element - The element to check
   * @returns {Object} - Position information
   */
  function getElementPosition(element) {
    try {
      const rect = element.getBoundingClientRect();
      return {
        top: rect.top,
        left: rect.left,
        bottom: rect.bottom,
        right: rect.right,
        width: rect.width,
        height: rect.height,
        viewportHeight: window.innerHeight,
        viewportWidth: window.innerWidth,
        isTopHalf: rect.top < window.innerHeight / 2,
        isBottomHalf: rect.bottom > window.innerHeight / 2
      };
    } catch (error) {
      console.error("CssModifier: Error getting position", error);
      return {
        top: 0,
        left: 0,
        bottom: 0,
        right: 0,
        width: 0,
        height: 0,
        viewportHeight: window.innerHeight,
        viewportWidth: window.innerWidth,
        isTopHalf: true,
        isBottomHalf: false
      };
    }
  }
  
  /**
   * Generate CSS rules to improve input field positions
   * @returns {Array} - An array of CSS rules
   */
  async function generateImprovedInputRules() {
    console.log("CssModifier: Generating improved input rules using LLM");
    const inputSelectors = findInputSelectors();
    const rules = [];

    for (const input of inputSelectors) {
      const position = input.position;

      // Only consider modifying inputs at the bottom of the screen
      if (position.isBottomHalf && position.top > position.viewportHeight * 0.6) {
        // Construct a natural language description for the LLM
        const description = `Move the input field with selector "${input.selector}" to eye level. It is currently at the bottom of the screen. Ensure it is visible and does not overlap with other content. Its current position is top: ${position.top}px, viewport height: ${position.viewportHeight}px. Also, add padding to its parent if necessary to prevent layout shifts.`;

        try {
          // Request CSS rules from LLM Service
          const llmRules = await window.LLMService.generateCssRules(description, window.LLMService.currentModel || 'mistral');
          if (llmRules && Array.isArray(llmRules)) {
            rules.push(...llmRules);
            console.log(`CssModifier: LLM generated ${llmRules.length} rules for ${input.selector}`);
          }
        } catch (error) {
          console.error(`CssModifier: Error generating LLM rules for ${input.selector}:`, error);
          // Fallback to a simple rule if LLM fails
          rules.push({
            selector: input.selector,
            styles: {
              'position': 'relative',
              'top': `-${Math.round(position.viewportHeight * 0.3)}px`,
              'z-index': '100'
            }
          });
        }

        // The LLM should handle padding, so no separate parent padding logic here.
      }
    }

    console.log("CssModifier: Generated", rules.length, "improved input rules");
    return rules;
  }
  
  /**
   * Generate improved readability rules
   * @returns {Array} - An array of CSS rules
   */
  function generateReadabilityRules() {
    console.log("CssModifier: Generating readability rules");
    const rules = [];
    
    // Find content containers
    const contentSelectors = [
      'article',
      'main',
      '.content',
      '.main-content',
      '.post',
      '.article',
      'section',
      '[role="main"]'
    ];
    
    // Check if any of these selectors have elements
    for (const selector of contentSelectors) {
      const elements = document.querySelectorAll(selector);
      if (elements.length > 0) {
        rules.push({
          selector: selector,
          styles: {
            'max-width': '800px',
            'margin': '0 auto',
            'line-height': '1.6',
            'font-size': '16px',
            'padding': '0 20px'
          }
        });
      }
    }
    
    // Style paragraphs and lists for better readability
    if (document.querySelectorAll('p, ul, ol').length > 10) {
      rules.push({
        selector: 'p, li',
        styles: {
          'line-height': '1.6',
          'margin-bottom': '1em',
          'font-size': '16px',
          'color': '#333'
        }
      });
    }
    
    // Improve headings
    rules.push({
      selector: 'h1, h2, h3, h4, h5, h6',
      styles: {
        'line-height': '1.3',
        'margin-top': '1.5em',
        'margin-bottom': '0.5em',
        'color': '#111'
      }
    });
    
    console.log("CssModifier: Generated", rules.length, "readability rules");
    return rules;
  }
  
  /**
   * Apply auto-generated rules for the current page
   */
  async function applyAutoRules() {
    console.log("CssModifier: Applying auto rules");
    try {
      const improvedInputRules = await generateImprovedInputRules();
      const readabilityRules = generateReadabilityRules();
      
      const combinedRules = [...improvedInputRules, ...readabilityRules];
      
      if (combinedRules.length > 0) {
        applyRules(combinedRules);
        return true;
      }
    } catch (error) {
      console.error("CssModifier: Error applying auto rules", error);
    }
    
    return false;
  }
  
  // Public API
  return {
    applyRules,
    removeAllRules,
    findInputSelectors,
    generateImprovedInputRules,
    generateReadabilityRules,
    applyAutoRules,
    showCssIndicator
  };
})();

// Make it available globally
window.CssModifier = CssModifier;